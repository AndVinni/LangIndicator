Ты — опытный системный программист и низкоуровневый разработчик для Windows 11 на языке C++ (C++17). Твоя задача — исходники утилиты, которая:

1. Автозапускается через реестр.
2. Реагирует на левый клик мыши и смену раскладки.
3. Показывает полупрозрачный прямоугольник с текстом текущей раскладки.
4. Анимация: пауза displayTimeMs, затем fade‑out по alphaStep.
5. Параметры из config.json (LoadOrCreate).
6. Чистый Win32 + STL, комментарии на русском.

---

## 1. main.cpp
```cpp
// main.cpp — точка входа: автозапуск, загрузка конфигурации, запуск индикатора
#include "config.h"
#include "langindicator.h"
#include <Windows.h>

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int)
{
    RegisterAutoRun();                    // автозапуск

    Config cfg;                           // конфигурация
    cfg.LoadOrCreate();

    LangIndicator indicator(&cfg);       // передаём конфиг
    if (!indicator.Init(hInstance))      // инициализация окна и Raw Input
        return -1;

    indicator.Run();                      // цикл сообщений
    return 0;
}
```

---

## 2. config.h / config.cpp
```cpp
// config.h — работа с config.json и автозапуск
#pragma once
#include <string>

void RegisterAutoRun();

struct Config {
    int width;
    int height;
    int fontSize;
    BYTE initialAlpha;
    int displayTimeMs;
    int fadeIntervalMs;
    BYTE alphaStep;
    std::wstring bgColor;
    std::wstring textColor;

    void LoadOrCreate();
};
```

```cpp
// config.cpp — реализация Config::LoadOrCreate и RegisterAutoRun
#include "config.h"
#include <Windows.h>
#include <shlwapi.h>
#include <fstream>
#include <sstream>
#pragma comment(lib, "shlwapi.lib")

static const wchar_t* CONFIG_NAME = L"config.json";

void RegisterAutoRun() {
    HKEY hKey;
    RegCreateKeyExW(HKEY_CURRENT_USER,
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        0, nullptr, 0, KEY_WRITE, nullptr, &hKey, nullptr);
    wchar_t path[MAX_PATH];
    GetModuleFileNameW(nullptr, path, MAX_PATH);
    RegSetValueExW(hKey, L"LangIndicator", 0, REG_SZ,
        reinterpret_cast<const BYTE*>(path),
        static_cast<DWORD>((wcslen(path)+1)*sizeof(wchar_t)));
    RegCloseKey(hKey);
}

void Config::LoadOrCreate() {
    wchar_t modPath[MAX_PATH];
    GetModuleFileNameW(nullptr, modPath, MAX_PATH);
    PathRemoveFileSpecW(modPath);
    std::wstring cfgPath = std::wstring(modPath) + L"\\" + CONFIG_NAME;

    if (!PathFileExistsW(cfgPath.c_str())) {
        width = 200; height = 50; fontSize = 24;
        initialAlpha = 192; displayTimeMs = 1500;
        fadeIntervalMs = 30; alphaStep = 5;
        bgColor = L"#000000"; textColor = L"#FFFFFF";
        std::wofstream f(cfgPath);
        f << L"{\n"
          << L"  \"width\": " << width << L",\n"
          << L"  \"height\": " << height << L",\n"
          << L"  \"fontSize\": " << fontSize << L",\n"
          << L"  \"initialAlpha\": " << initialAlpha << L",\n"
          << L"  \"displayTimeMs\": " << displayTimeMs << L",\n"
          << L"  \"fadeIntervalMs\": " << fadeIntervalMs << L",\n"
          << L"  \"alphaStep\": " << alphaStep << L",\n"
          << L"  \"bgColor\": \"" << bgColor << L"\",\n"
          << L"  \"textColor\": \"" << textColor << L"\"\n"
          << L"}\n";
        return;
    }
    // простой парсинг
    std::wifstream f(cfgPath);
    std::wstringstream ss; ss << f.rdbuf(); std::wstring s = ss.str();
    auto getInt=[&](std::wstring key){ size_t p=s.find(key); if(p==std::wstring::npos) return 0; return _wtoi(s.c_str()+s.find(L":",p)+1); };
    auto getByte=[&](std::wstring key){ return static_cast<BYTE>(getInt(key)); };
    auto getStr=[&](std::wstring key){ size_t p=s.find(key); if(p==std::wstring::npos) return std::wstring(); p=s.find(L'"',p+key.size())+1; size_t e=s.find(L'"',p); return s.substr(p,e-p); };
    width = getInt(L"\"width\"");
    height = getInt(L"\"height\"");
    fontSize = getInt(L"\"fontSize\"");
    initialAlpha = getByte(L"\"initialAlpha\"");
    displayTimeMs = getInt(L"\"displayTimeMs\"");
    fadeIntervalMs = getInt(L"\"fadeIntervalMs\"");
    alphaStep = getByte(L"\"alphaStep\"");
    bgColor = getStr(L"\"bgColor\"");
    textColor = getStr(L"\"textColor\"");
}
```

---

## 3. langindicator.h
```cpp
#pragma once
#include <windows.h>
#include <string>
#include "config.h"

class LangIndicator {
public:
    explicit LangIndicator(const Config* cfg);
    ~LangIndicator();

    bool Init(HINSTANCE hInstance);
    void Run();

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

private:
    const Config* cfg_;         // конфигурация
    HWND hwnd_;
    HINSTANCE hInst_;
    UINT_PTR displayTimerId_;
    UINT_PTR fadeTimerId_;
    BYTE currentAlpha_;
    std::wstring currentLayout_;

    void RegisterRawInput();
    void ShowIndicator();
    void UpdateLayout();
};
```

---

## 4. langindicator.cpp
```cpp
#include "langindicator.h"
#include <vector>

static constexpr UINT_PTR DISPLAY_TIMER_ID = 1;
static constexpr UINT_PTR FADE_TIMER_ID    = 2;

LangIndicator::LangIndicator(const Config* cfg)
    : cfg_(cfg)
    , hwnd_(nullptr)
    , hInst_(nullptr)
    , displayTimerId_(DISPLAY_TIMER_ID)
    , fadeTimerId_(FADE_TIMER_ID)
    , currentAlpha_(0)
{
}

LangIndicator::~LangIndicator() {
    if (hwnd_) DestroyWindow(hwnd_);
}

bool LangIndicator::Init(HINSTANCE hInstance) {
    hInst_ = hInstance;
    WNDCLASSW wc = {};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInst_;
    wc.lpszClassName = L"LangIndicatorWindow";
    RegisterClassW(&wc);

    hwnd_ = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_TOOLWINDOW,
        wc.lpszClassName,
        nullptr,
        WS_POPUP,
        CW_USEDEFAULT, CW_USEDEFAULT,
        cfg_->width, cfg_->height,
        nullptr, nullptr, hInst_, this);
    if (!hwnd_) return false;

    SetWindowLongPtr(hwnd_, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));
    ShowWindow(hwnd_, SW_HIDE);
    RegisterRawInput();
    return true;
}

void LangIndicator::Run() {
    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}

void LangIndicator::RegisterRawInput() {
    RAWINPUTDEVICE rid{0};
    rid.usUsagePage = 0x01;
    rid.usUsage     = 0x02;
    rid.dwFlags     = RIDEV_INPUTSINK;
    rid.hwndTarget  = hwnd_;
    RegisterRawInputDevices(&rid, 1, sizeof(rid));
}

void LangIndicator::ShowIndicator() {
    UpdateLayout();
    currentAlpha_ = cfg_->initialAlpha;
    POINT pt; GetCursorPos(&pt);
    SetWindowPos(hwnd_, HWND_TOPMOST, pt.x, pt.y,
                 cfg_->width, cfg_->height,
                 SWP_NOACTIVATE);
    SetLayeredWindowAttributes(hwnd_, 0, currentAlpha_, LWA_ALPHA);
    ShowWindow(hwnd_, SW_SHOWNA);
    UpdateWindow(hwnd_);
    SetTimer(hwnd_, displayTimerId_, cfg_->displayTimeMs, nullptr);
}

void LangIndicator::UpdateLayout() {
    wchar_t name[KL_NAMELENGTH] = {};
    if (GetKeyboardLayoutNameW(name)) currentLayout_ = name;
    else currentLayout_ = L"??";
}

LRESULT CALLBACK LangIndicator::WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    auto self = reinterpret_cast<LangIndicator*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (msg) {
    case WM_INPUT: {
        HRAWINPUT hRaw = reinterpret_cast<HRAWINPUT>(lp);
        UINT size = 0;
        if (GetRawInputData(hRaw, RID_INPUT, nullptr, &size, sizeof(RAWINPUTHEADER)) == size) {
            std::vector<BYTE> buf(size);
            if (GetRawInputData(hRaw, RID_INPUT, buf.data(), &size, sizeof(RAWINPUTHEADER)) == size) {
                RAWINPUT* ri = reinterpret_cast<RAWINPUT*>(buf.data());
                if (ri->header.dwType == RIM_TYPEMOUSE &&
                    (ri->data.mouse.usButtonFlags & RI_MOUSE_LEFT_BUTTON_DOWN))
                {
                    self->ShowIndicator();
                }
            }
        }
        return 0;
    }
    case WM_INPUTLANGCHANGE:
        if (self) self->ShowIndicator();
        return 0;
    case WM_SETTINGCHANGE:
        if (lp && wcscmp(reinterpret_cast<LPCWSTR>(lp), L"intl") == 0)
            if (self) self->ShowIndicator();
        return 0;
    case WM_TIMER:
        if (!self) break;
        if (wp == self->displayTimerId_) {
            KillTimer(hwnd, self->displayTimerId_);
            SetTimer(hwnd, self->fadeTimerId_, self->cfg_->fadeIntervalMs, nullptr);
        } else if (wp == self->fadeTimerId_) {
            if (self->currentAlpha_ > self->cfg_->alphaStep) {
                self->currentAlpha_ -= self->cfg_->alphaStep;
                SetLayeredWindowAttributes(hwnd, 0, self->currentAlpha_, LWA_ALPHA);
            } else {
                KillTimer(hwnd, self->fadeTimerId_);
                ShowWindow(hwnd, SW_HIDE);
            }
        }
        return 0;
    case WM_PAINT: {
        if (!self) break;
        PAINTSTRUCT ps; HDC dc = BeginPaint(hwnd, &ps);
        SetBkMode(dc, TRANSPARENT);
        COLORREF textColor = /* парсер cfg_->textColor */ RGB(255,255,255);
        SetTextColor(dc, textColor);
        HFONT font = CreateFontW(self->cfg_->fontSize,0,0,0,FW_NORMAL,0,0,0,
                                  DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                  CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY,
                                  DEFAULT_PITCH, L"Segoe UI");
        SelectObject(dc, font);
        RECT rc; GetClientRect(hwnd, &rc);
        DrawTextW(dc, self->currentLayout_.c_str(), -1, &rc,
                  DT_CENTER|DT_VCENTER|DT_SINGLELINE);
        DeleteObject(font);
        EndPaint(hwnd, &ps);
        return 0;
    }
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    default:
        return DefWindowProcW(hwnd, msg, wp, lp);
    }
}
```
