# Решение: LangIndicator (C++17, Win32) — обновлённый с явными W-версиями API

---

## 1. main.cpp
```cpp
// main.cpp — точка входа, регистрация автозагрузки и запуск цикла обработки сообщений
#include "config.h"
#include "langindicator.h"
#include <Windows.h>

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE, PWSTR, int)
{
    // 1. Проверяем и создаём запись в автозагрузке
    RegisterAutoRun();  // в config.cpp использует RegCreateKeyExW/RegSetValueExW

    // 2. Загружаем конфигурацию
    Config cfg;
    cfg.LoadOrCreate();

    // 3. Инициализируем индикатор
    LangIndicator indicator(&cfg);
    indicator.Initialize(hInstance);

    // 4. Запускаем цикл обработки сообщений Win32
    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
    return 0;
}
```

---

## 2. config.h
```cpp
// config.h — объявление структуры конфигурации и функций работы с JSON
#pragma once
#include <string>

// Регистрирует приложение в автозагрузке (WinAPI Unicode)
void RegisterAutoRun();

struct Config {
    int width;
    int height;
    int fontSize;
    int initialAlpha;
    int displayTimeMs;
    int fadeTimeMs;
    std::wstring bgColor;
    std::wstring textColor;

    // Загружает или создаёт config.json
    void LoadOrCreate();
};
```

---

## 3. config.cpp
```cpp
// config.cpp — реализация загрузки/сохранения config.json и автозапуска (W-версии)
#include "config.h"
#include <Windows.h>
#include <fstream>
#include <sstream>
#include <shlwapi.h>   // PathFileExistsW, PathRemoveFileSpecW
#pragma comment(lib, "shlwapi.lib")

static const wchar_t* CONFIG_NAME = L"config.json";

void RegisterAutoRun() {
    HKEY hKey;
    // Создаём/открываем ветку реестра для автозапуска
    RegCreateKeyExW(HKEY_CURRENT_USER,
        L"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
        0, nullptr, 0, KEY_WRITE, nullptr, &hKey, nullptr);
    wchar_t path[MAX_PATH];
    GetModuleFileNameW(nullptr, path, MAX_PATH);
    RegSetValueExW(hKey, L"LangIndicator", 0, REG_SZ,
        reinterpret_cast<const BYTE*>(path),
        static_cast<DWORD>((wcslen(path) + 1) * sizeof(wchar_t)));
    RegCloseKey(hKey);
}

void Config::LoadOrCreate() {
    wchar_t modulePath[MAX_PATH];
    GetModuleFileNameW(nullptr, modulePath, MAX_PATH);
    PathRemoveFileSpecW(modulePath);
    std::wstring configPath = std::wstring(modulePath) + L"\\" + CONFIG_NAME;

    if (!PathFileExistsW(configPath.c_str())) {
        // Дефолтные значения
        width = 200;
        height = 50;
        fontSize = 24;
        initialAlpha = 192;
        displayTimeMs = 1500;
        fadeTimeMs = 1000;
        bgColor = L"#000000";
        textColor = L"#FFFFFF";

        std::wofstream f(configPath);
        f << L"{\n"
          << L"  \"width\": " << width << L",\n"
          << L"  \"height\": " << height << L",\n"
          << L"  \"fontSize\": " << fontSize << L",\n"
          << L"  \"initialAlpha\": " << initialAlpha << L",\n"
          << L"  \"displayTimeMs\": " << displayTimeMs << L",\n"
          << L"  \"fadeTimeMs\": " << fadeTimeMs << L",\n"
          << L"  \"bgColor\": \"" << bgColor << L"\",\n"
          << L"  \"textColor\": \"" << textColor << L"\"\n"
          << L"}\n";
        f.close();
    } else {
        // Простейший парсинг JSON
        std::wifstream f(configPath);
        std::wstringstream ss;
        ss << f.rdbuf();
        std::wstring s = ss.str();
        auto getInt = [&](const std::wstring& key)->int {
            size_t pos = s.find(key);
            if (pos == std::wstring::npos) return 0;
            pos = s.find(L":", pos) + 1;
            return _wtoi(s.c_str() + pos);
        };
        auto getStr = [&](const std::wstring& key)->std::wstring {
            size_t pos = s.find(key);
            if (pos == std::wstring::npos) return L"";
            pos = s.find(L"\"", pos + key.length()) + 1;
            size_t end = s.find(L"\"", pos);
            return s.substr(pos, end - pos);
        };
        width         = getInt(L"\"width\"");
        height        = getInt(L"\"height\"");
        fontSize      = getInt(L"\"fontSize\"");
        initialAlpha  = getInt(L"\"initialAlpha\"");
        displayTimeMs = getInt(L"\"displayTimeMs\"");
        fadeTimeMs    = getInt(L"\"fadeTimeMs\"");
        bgColor       = getStr(L"\"bgColor\"");
        textColor     = getStr(L"\"textColor\"");
    }
}
```

---

## 4. langindicator.h
```cpp
// langindicator.h — класс для отслеживания событий и отрисовки индикатора
#pragma once
#include <windows.h>
#include <string>

class LangIndicator {
public:
    LangIndicator();
    ~LangIndicator();

    // Инициализация: регистрирует класс окна, создаёт окно и настраивает Raw Input
    bool Init(HINSTANCE hInstance);

    // Запуск цикла обработки сообщений
    void Run();

    // Функция окна
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

private:
    HWND        hwnd_;             // дескриптор окна
    HINSTANCE   hInstance_;        // дескриптор модуля
    UINT_PTR    displayTimerId_;   // ID таймера показа
    UINT_PTR    fadeTimerId_;      // ID таймера исчезновения
    BYTE        currentAlpha_;     // текущая прозрачность
    BYTE        initialAlpha_;     // начальная прозрачность из конфигурации
    int         displayTimeMs_;    // время показа до fade-out
    int         fadeIntervalMs_;   // интервал шагов fade-out
    int         alphaStep_;        // шаг уменьшения прозрачности
    std::wstring currentLayout_;   // строковое имя текущей раскладки

    // Зарегистрировать прием сырого ввода мыши
    void RegisterRawInput();

    // Отобразить индикатор
    void ShowIndicator();

    // Обновить currentLayout_ из системы
    void UpdateLayout();
};
```

## 5. langindicator.cpp
```cpp
// langindicator.cpp — реализация методов класса LangIndicator
#include "langindicator.h"
#include <vector>
#include <shellapi.h>

// Идентификаторы таймеров
static constexpr UINT_PTR DISPLAY_TIMER_ID = 1;
static constexpr UINT_PTR FADE_TIMER_ID    = 2;

LangIndicator::LangIndicator()
    : hwnd_(nullptr)
    , hInstance_(nullptr)
    , displayTimerId_(DISPLAY_TIMER_ID)
    , fadeTimerId_(FADE_TIMER_ID)
    , currentAlpha_(0)
    , initialAlpha_(192)        // по умолчанию 75% прозрачности
    , displayTimeMs_(1500)
    , fadeIntervalMs_(30)
    , alphaStep_(5)
{
}

LangIndicator::~LangIndicator()
{
    if (hwnd_) DestroyWindow(hwnd_);
}

bool LangIndicator::Init(HINSTANCE hInstance)
{
    hInstance_ = hInstance;
    // Регистрируем класс окна
    WNDCLASSW wc = {};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance_;
    wc.lpszClassName = L"LangIndicatorWindow";
    wc.hCursor       = LoadCursor(nullptr, IDC_ARROW);
    RegisterClassW(&wc);

    // Создаем окно без рамки, прозрачное
    hwnd_ = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_TOOLWINDOW,
        wc.lpszClassName,
        nullptr,
        WS_POPUP,
        CW_USEDEFAULT, CW_USEDEFAULT,
        200, 50,
        nullptr, nullptr, hInstance_, this);
    if (!hwnd_) return false;

    // Сохраняем указатель на объект
    SetWindowLongPtr(hwnd_, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(this));

    // Изначально окно скрыто
    ShowWindow(hwnd_, SW_HIDE);

    // Регистрируем Raw Input для мыши
    RegisterRawInput();
    return true;
}

void LangIndicator::Run()
{
    MSG msg;
    while (GetMessageW(&msg, nullptr, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}

void LangIndicator::RegisterRawInput()
{
    RAWINPUTDEVICE rid;
    rid.usUsagePage = 0x01; // Generic Desktop Controls
    rid.usUsage     = 0x02; // Mouse
    rid.dwFlags     = RIDEV_INPUTSINK;
    rid.hwndTarget  = hwnd_;
    RegisterRawInputDevices(&rid, 1, sizeof(rid));
}

void LangIndicator::ShowIndicator()
{
    // Обновляем раскладку
    UpdateLayout();

    // Начальная прозрачность
    currentAlpha_ = initialAlpha_;

    // Позиционируем окно под курсором
    POINT pt;
    GetCursorPos(&pt);
    SetWindowPos(hwnd_, HWND_TOPMOST, pt.x, pt.y,
                 200, 50, SWP_NOACTIVATE);

    // Устанавливаем альфа-канал
    SetLayeredWindowAttributes(hwnd_, 0, currentAlpha_, LWA_ALPHA);
    ShowWindow(hwnd_, SW_SHOWNA);
    UpdateWindow(hwnd_);

    // Запускаем таймер показа
    SetTimer(hwnd_, displayTimerId_, displayTimeMs_, nullptr);
}

void LangIndicator::UpdateLayout()
{
    wchar_t name[KL_NAMELENGTH] = {};
    if (GetKeyboardLayoutNameW(name)) {
        currentLayout_ = name;
    } else {
        currentLayout_ = L"--";
    }
}

LRESULT CALLBACK LangIndicator::WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    LangIndicator* self = reinterpret_cast<LangIndicator*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (msg)
    {
    case WM_CREATE:
        return 0;

    case WM_INPUT:
    {
        HRAWINPUT hRaw = reinterpret_cast<HRAWINPUT>(lp);
        UINT size = 0;
        GetRawInputData(hRaw, RID_INPUT, nullptr, &size, sizeof(RAWINPUTHEADER));
        std::vector<BYTE> buffer(size);
        if (GetRawInputData(hRaw, RID_INPUT, buffer.data(), &size, sizeof(RAWINPUTHEADER)) == size) {
            RAWINPUT* ri = reinterpret_cast<RAWINPUT*>(buffer.data());
            if (ri->header.dwType == RIM_TYPEMOUSE &&
                (ri->data.mouse.usButtonFlags & RI_MOUSE_LEFT_BUTTON_DOWN))
            {
                self->ShowIndicator();
            }
        }
        return 0;
    }

    case WM_INPUTLANGCHANGE:
        if (self) self->ShowIndicator();
        return 0;

    case WM_SETTINGCHANGE:
        if (lp && wcscmp(reinterpret_cast<LPCWSTR>(lp), L"intl") == 0) {
            if (self) self->ShowIndicator();
        }
        return 0;

    case WM_TIMER:
        if (!self) break;
        if (wp == self->displayTimerId_) {
            // Сначала убираем таймер показа
            KillTimer(hwnd, self->displayTimerId_);
            // Рассчитываем шаг уменьшения альфы
            // alphaStep_ уже задан в конструкторе
            SetTimer(hwnd, self->fadeTimerId_, self->fadeIntervalMs_, nullptr);
        }
        else if (wp == self->fadeTimerId_) {
            if (self->currentAlpha_ > self->alphaStep_) {
                self->currentAlpha_ -= self->alphaStep_;
                SetLayeredWindowAttributes(hwnd, 0, self->currentAlpha_, LWA_ALPHA);
            } else {
                KillTimer(hwnd, self->fadeTimerId_);
                ShowWindow(hwnd, SW_HIDE);
            }
        }
        return 0;

    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC dc = BeginPaint(hwnd, &ps);
        // Простой вывод текста текущей раскладки
        SetBkMode(dc, TRANSPARENT);
        SetTextColor(dc, RGB(255,255,255));
        HFONT font = CreateFontW(24,0,0,0,FW_NORMAL, FALSE,FALSE,FALSE,
                                  DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                  CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY,
                                  DEFAULT_PITCH, L"Segoe UI");
        SelectObject(dc, font);
        RECT r; GetClientRect(hwnd, &r);
        DrawTextW(dc, self->currentLayout_.c_str(), -1, &r,
                  DT_CENTER | DT_VCENTER | DT_SINGLELINE);
        DeleteObject(font);
        EndPaint(hwnd, &ps);
        return 0;
    }

    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    default:
        return DefWindowProcW(hwnd, msg, wp, lp);
    }
    return 0;
}
```
```cpp
// langindicator.cpp — реализация отслеживания событий и отрисовки
#include "langindicator.h"
#include <string>

static LangIndicator* g_instance = nullptr;

LangIndicator::LangIndicator(const Config* cfg)
    : cfg_(cfg), wnd_(nullptr), font_(nullptr), mouseHook_(nullptr), kbHook_(nullptr), fadeTimerId_(0), currentAlpha_(0)
{
    g_instance = this;
}

void LangIndicator::Initialize(HINSTANCE hInstance)
{
    // Регистрируем класс окна Unicode
    WNDCLASSW wc = {};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInstance;
    wc.lpszClassName = L"LangIndicatorWindow";
    RegisterClassW(&wc);

    // Создаём прозрачное окно без рамки
    wnd_ = CreateWindowExW(
        WS_EX_LAYERED | WS_EX_TRANSPARENT | WS_EX_TOOLWINDOW,
        L"LangIndicatorWindow",
        nullptr,
        WS_POPUP,
        0, 0, cfg_->width, cfg_->height,
        nullptr, nullptr, hInstance, nullptr);

    // Создаём шрифт
    font_ = CreateFontW(
        cfg_->fontSize, 0, 0, 0, FW_NORMAL,
        FALSE, FALSE, FALSE, DEFAULT_CHARSET,
        OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
        CLEARTYPE_QUALITY, DEFAULT_PITCH, L"Segoe UI");

    // Устанавливаем хуки Unicode-версии
    mouseHook_ = SetWindowsHookExW(WH_MOUSE_LL, MouseProc, hInstance, 0);
    kbHook_    = SetWindowsHookExW(WH_KEYBOARD_LL, KeyboardProc, hInstance, 0);
}

LRESULT CALLBACK LangIndicator::WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg) {
    case WM_PAINT: {
        PAINTSTRUCT ps;
        HDC dc = BeginPaint(hwnd, &ps);
        
        // Настройка альфа-смешивания
        BLENDFUNCTION bf = { AC_SRC_OVER, 0, static_cast<BYTE>(g_instance->currentAlpha_), 0 };
        SIZE sz = { g_instance->cfg_->width, g_instance->cfg_->height };
        
        HDC memDC = CreateCompatibleDC(dc);
        HBITMAP bmp = CreateCompatibleBitmap(dc, sz.cx, sz.cy);
        SelectObject(memDC, bmp);

        // TODO: преобразовать #RRGGBB в COLORREF
        RECT r = {0,0, sz.cx, sz.cy};
        HBRUSH brush = CreateSolidBrush(RGB(0,0,0));
        FillRect(memDC, &r, brush);
        DeleteObject(brush);

        SetBkMode(memDC, TRANSPARENT);
        SelectObject(memDC, g_instance->font_);
        SetTextColor(memDC, RGB(255,255,255));
        wchar_t layout[KL_NAMELENGTH];
        GetKeyboardLayoutNameW(layout);
        DrawTextW(memDC, layout, -1, &r, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

        UpdateLayeredWindow(hwnd, dc, nullptr, &sz, memDC, nullptr, 0, &bf, ULW_ALPHA);

        DeleteObject(bmp);
        DeleteDC(memDC);
        EndPaint(hwnd, &ps);
        break;
    }
    case WM_TIMER:
        if (wp == g_instance->fadeTimerId_) {
            int step = g_instance->cfg_->initialAlpha * 10 / g_instance->cfg_->fadeTimeMs;
            g_instance->currentAlpha_ -= step;
            if (g_instance->currentAlpha_ <= 0) {
                KillTimer(hwnd, g_instance->fadeTimerId_);
                ShowWindow(hwnd, SW_HIDE);
            } else {
                InvalidateRect(hwnd, nullptr, TRUE);
            }
        }
        break;
    }
    return DefWindowProcW(hwnd, msg, wp, lp);
}

LRESULT CALLBACK LangIndicator::MouseProc(int nCode, WPARAM wp, LPARAM lp)
{
    if (nCode == HC_ACTION) {
        g_instance->ShowIndicator();
    }
    return CallNextHookEx(nullptr, nCode, wp, lp);
}

LRESULT CALLBACK LangIndicator::KeyboardProc(int nCode, WPARAM wp, LPARAM lp)
{
    if (nCode == HC_ACTION && wp == WM_INPUTLANGCHANGE) {
        g_instance->ShowIndicator();
    }
    return CallNextHookEx(nullptr, nCode, wp, lp);
}

void LangIndicator::ShowIndicator()
{
    POINT pt;
    GetCursorPos(&pt);
    SetWindowPos(wnd_, HWND_TOPMOST, pt.x, pt.y,
        cfg_->width, cfg_->height, SWP_NOACTIVATE);

    currentAlpha_ = cfg_->initialAlpha;
    ShowWindow(wnd_, SW_SHOWNA);
    InvalidateRect(wnd_, nullptr, TRUE);

    fadeTimerId_ = 1;
    SetTimer(wnd_, fadeTimerId_, 10, nullptr);
}
```
